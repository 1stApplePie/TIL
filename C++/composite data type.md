# 복합 데이터형
일상에서 코딩을 하다보면 앞서 배운 기본 데이터형만 가지고는 이러한 데이터를 처리할 수가 없다. 그렇기 때문에 C++는 복합 데이터형을 제공한다. 복합 데이터형은 기본 정수형과 부동 소수점형으로부터 만들어진다. 이들 복합 데이터형 중에서 가장 복잡한 것은 클래스이다.  
C++는 C로부터 가져온 몇 가지 다른 복합형들도 제공한다. 예를 들어, 배열(array)은 동일한 데이터형의 값 여러 개를 연속적으로 저장할 수 있다. 어떤 특정한 종류의 배열은 무자열 즉, 연속된 문자들을 저장할 수 있다. 구조체(structure)는 종류가 다른 여러 데이터형의 값을 함께 저장할 수 있다. 또한 포인터(pointer)라는 것이 있다. 포인터는 데이터가 저장되어 있는 주소를 컴퓨터에게 알려 주는 변수이다. 이번 단원에서는 클래스를 제외한 모든 복합형들에 대해 알아본다. 또한 new와 delete를 처음으로 살펴보고, 그들을 사용하여 데이터를 다루는 법을 알아본다. 그리고 문자열을 다루는 또 다른 방법인 C++의 string클래스르 간단하게 알아본다.
<hr> 

## 1. 배열
배열(array)은 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조이다.  
배열은 선언 구문을 사용하여 생성한다. 배열 선언 구문에서는 다음과 같은 세 가지를 선언한다.
<ul type = square>
<li> 각 원소에 저장될 값의 데이터형</li>
<li> 배열의 이름</li>
<li> 배열 원소의 개수</li>
</ul>

C++에서는 간단한 변수의 선언 형식을 수정하여 배열을 선언한다. 즉, 배열 원소의 개수를 대괄호 안에 넣어 선언한다.
```
short months(12);       // 12개의 short형 값을 넣을 수 있는 배열을 생성
```
위의 코드는 배열의 이름이 months이고, 12개의 원소를 가지며, 각 원소에는 short형 값을 저장할 수 있다는 것을 나타낸다. 배열의 각 원소는 개별적으로 간단한 변수처럼 취급할 수 있는 변수이다.  
  
다음은 배열을 선언하는 일반적인 형식이다.
```
typeName arrayName(arraySize);
```
원소의 개수를 나타내는 arraysize는 값 10 또는 const 기호 상수와 같은 정수 상수이거나, 또는 컴파일할 때 값이 결정되는 8 * sizeof(int)와 같은 상수 수식이어야 한다. 특히 프로그램이 실행되는 동안에 값이 결정되는 변수는 arraySize가 될 수 없다. 그러나 new 연산자를 사용하여 이러한 제약을 피하는 방법도 있다.  
  
배열이 여러 가지 용도로 유용한 것은 각각의 배열 원소에 개별적으로 접근할 수 있기 때문이다. 개별적인 접근을 허용하기 위해 인덱스(subscript) 또는 인덱스(index)를 사용하여 배열 원소에 차례로 번호가 매겨진다. C++의 배열 인덱스는 항상 0부터 시작한다. 그리고 C++는 대괄호 안에 인덱스를 넣어 배열 원소를 지정한다.  
  
Listing 4.1은 배열을 선언하고, 배열 원소에 값을 대입하며, 배열을 초기화하는 것과 같은 배열에 관련된 몇 가지 사항을 보여준다.
```
// Listing 4.1
// arrayone.cpp

#include <iostream>
int main()
{
    using namespace std;
    int yams[3];                // 3개의 원소를 가진 배열을 선언
    yams[0] = 7;                // 첫 번째 원소에 값을 대입
    yams[1] = 8;
    yams[2] = 6;

    int yamcosts[3] = {200, 300, 50};   // 배열을 생성하고 초기화
    // 참고: 사용하는 C++ 컴파일러나 번역기가 이 배열을 초기화할 수 없다면
    // int yamcosts[3] 대신에 static int yamcosts[3]을 사용하라

    cout << "고구마 합계 = ";
    cout << yams[0] + yams[1] + yams[2] << endl;
    cout << yams[1] << "개가 들어 있는 포장은 ";
    cout << "개당 " << yamcosts[1] << "원씩입니다.\n";
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    total = total + yams[2] * yamcosts[2];
    cout << "세 포장의 총 가격은 " << total << "원입니다.\n";
    cout << "\nyams 배열의 크기는 " << sizeof yams;
    cout << "바이트입니다.\n";
    cout << "원소 하나의 크기는 " << sizeof yams[0];
    cout << "바이트입니다.\n";
    return 0;
}
```

#### 프로그램 분석
Listing 4.1 프로그램은 3개의 원소를 가진 yams라는 배열을 생성한다. yams는 원소가 3개인 배열이므로 배열 원소들의 인덱스는 0, 1, 2가 된다.  
위 코드는 yams배열의 세 원소에 고지식한 방법으로 값을 대입하고 있다. 그러나 이렇게 하지 않고 선언 구문에서 배열 원소를 직접 초기화할 수도 있다. Listing 4.1은 yamcosts 배열에 이 방법으로 값을 대입하고 있다.
```
int yamcosts[3] = {200, 300 ,50};
```
이 방법은 배열 원소에 대입할 값들을 콤마로 구분하여 중괄호로 묶은 초기화 리스트를 간단하게 제공한다. 중괄호 안의 리스트에 빈칸이 있어도 되고 없어도 된다. 함수 안에서 정의된 배열을 초기화 하지 않으면, 배열 원소의 값들은 미확정 상태로 남는다. 즉, 배열 원소들은 그 메모리 위치에 전부터 우연히 남아있던 쓰레기 값들로 취한다.  

그리고 배열 원소들의 산술연산을 진행하였는데 인덱스와 대괄호의 사용 때문에 무척 고지식해 보인다. 하지만 아직 for문이나 while문에 대해 공부하지 않았으므로 이번 단원에서는 위와 같이 작성하였다.  
  
기억을 되살리면 sizeof 연산자는 데이터형이나 데이터 객체의 크기를 바이트 단위로 리턴한다. 배열 이름에 sizeof 연산자를 적용하면 그 배열의 전체 크기가 바이트 단위로 리턴된다. 그러나 배열 원소에 sizeof 연산자를 적용하면 배열 원소의 크기를 바이트 단위로 리턴한다.
  
### 배열 초기화 규칙

C++는 배열을 초기화하는 데 몇 가지 규칙을 적용하고 있다. 이 규칙은 배열 초기화를 할 수 있는 시기를 제한한다. 또한 배열 원소의 개수와 초기화 리스트에 제시된 값의 개수가 일치하지 않을 때 어떻게 할 것인지를 결정한다.
초기화 형식은 배열을 정의하는 곳에서만 사용할 수 있다. 초기화를 나중에 할 수는 없다. 배열을 다른 배열에 통째로 대입할 수도 없다.
```
int cards[4] = {3, 6, 8, 10}        // 맞다.
int hand[4];                        // 맞다.
hand[4] = {5, 6, 7, 8}              // 틀리다.
hand = cards;                       // 틀리다.
```
그러나 인덱스를 사용하여 배열 원소에 개별적으로 값을 대입하는 것은 언제든지 가능하다. 배열을 초기화할 때, 초기화 값의 개수를 배열 원소의 개수보다 모자라게 제공할 수도 있다.
```
float arr[5] = {5.0, 2.5};
```
배열을 부분적으로 초기화하면 컴파일러는 나머지 원소들을 자동으로 0으로 설정한다. 따라서 zeros와 같은 원소가 모두 0인 행렬은 배열의 첫 번째 원소만 0으로 초기화 시키면 간단하게 만들 수 있다.
```
long zeros[500] = {0};
```
배열을 초기화할 때 대괄호 속을 비워두면, 컴파일러가 초기화 값의 수를 헤아려 배열 원소의 개수를 결정한다.
```
short things[] = {1, 2, 3, 4};
```
배열 원소의 수가 4개인 short형의 배열 things를 생성한다.
<hr>

## 2. 문자열
문자열(string)이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말한다. C++는 두 가지 방법으로 문자열을 처리한다. 첫 번째는 C로부터 유래한 C 스타일의 문자열 처리 방법으로, 이 단원에서는 이 방법을 먼저 알아본다. 또 다른 방법은 단원의 뒤에서 알아본다.  
  
문자들이 메모리에 바이트 단위로 저장된다는 것은, 문자열을 char형의 배열에 저장할 수 있다는 것을 의미한다. 이때 문자열을 구성하는 각 문자들은 배열의 원소에 하나씩 저장된다.  
C 스타일의 문자열은 특별한 특징을 가지고 있다. 모든 문자열의 마지막 문자가 반드시 널 문자(null character)여야 한다는 것인데 널 문자는 \0로 쓰며, ASCII 코드가 0인 문자이다. 그것은 문자열의 끝을 표시한다. 다음 두 구문을 비교해보자.
```
char dog[8] = {'b', 'e' , 'a', 'u', 'x', ' ', 'I', 'I'};    // 문자열이 아니다.
char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};    // 문자열이다.
```
두 배열이 모두 char형의 배열이다. 그러나 두 번째 배열만이 문자열이다. 널 문자는 C스타일의 문자열에서 중요한 역할을 한다. 예를 들어 C++는 cout이 사용하는 함수들도 포함하여, 많은 문자열 처리 함수를 가지고 있다. 이 함수들은 널 문자를 만날 때까지 문자 단위로 문자열을 처리한다. 앞에 예로 든 cat문자열을 cout으로 출력하면, 8개의 문자를 출력하고 나서 널 문자를 만나면 출력을 중단한다.<br><br>

그러나 앞의 예에서 문자열이 아닌 dog를 cout으로 출력하면, 배열에 들어 있는 5개의 문자를 모두 출력한 뒤에도 그 이후의 메모리 내용을 한 바이트씩 문자로 간주하여 계속해서 출력한다. 출력은 우연히 널 문자를 만날 때까지 이어진다. 그러나 값이 0으로 설정되는 널 문자들은 메모리에 아주 흔하기 때문에, 출력이 그렇게 오래 지속되지는 않는다.<br><br>

앞의 예에서 문자열을 하나하나 작은 따옴표로 묶어 콤마로 구분하는 일은 매우 귀찮은 일이었다. 이보다 좋은 방법은 char형의 배열을 문자열로 초기화하는 것이다.
```
char bird[11] = "Mr.Cheeps"     // \0을 저장한다.
char fish[] = "Bubbles"         // 컴파일러가 알아서 처리한다.
```
위와 같이 큰 따옴표로 묶인 문자열을 문자열 상수(string constant 또는 string literal)이라 한다. 큰 따옴표로 묶인 문자열은 끝내기 널 문자를 암시적으로 갖고 있다. 그러미로 문자열의 끝에 널 문자를 명시적으로 넣을 필요가 없다.

```
char shirt_size = 'S';
char shirt_size = "S";
```
위 두 코드를 보자. 첫 코드의 'S'는 문자 상수 83을 의미하며 프로그램에서 실행하게 되면 문제가 발생하지 않는다. 두 번째 코드의 "S"는 내부적으로 문자열이 저장되어 있는 메모리 주소를 나타내며 코드는 char형 변수에 메모리 주소를 대입하는 코드이다. 메모리 주소와 char형은 다른 종류의 데이터형이기 때문에 에러가 발생한다. 이에 대해서는 뒤에 포인터를 다룰 때 더 알아보도록 하자.<br>

### 문자열 상수의 결합
어떤 문자열은 너무 길어서 한 행으로 표현할 수 없다. 이러한 경우에 C++에서는 문자열 상수들을 결합할 수 있다. 즉, 큰 따옴표로 묶인 두 문자열을 하나로 결합할 수 있다. 빈칸, 탭, 캐리지 리턴과 같은 화이트 스페이스(white space)로 분리된 두 개의 문자열 상수는 하나의 문자열 상수로 결합된다.
```
cout << "I'd give my right arm to be a great violinist.\n";
cout << "I'd give my right arm to be" "a great violinist.\n";
cout << "I'd give my right ar" "m to be a great violinist.\n"
```
위 세 개의 출력 구문은 모두 동일하다. 이때 결합된 문자열에는 어떠한 빈칸도 추가되지 않는다. \0을 뺀 첫 번째 문자열의 마지막 문자에 두 번째 문자열의 첫 문자가 이어진다. 즉, 첫 번째 문자열의 \0가 두 번째 문자열의 첫 문자로 대체된다.<br>

### 배열에 문자열 사용