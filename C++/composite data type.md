# 복합 데이터형
일상에서 코딩을 하다보면 앞서 배운 기본 데이터형만 가지고는 이러한 데이터를 처리할 수가 없다. 그렇기 때문에 C++는 복합 데이터형을 제공한다. 복합 데이터형은 기본 정수형과 부동 소수점형으로부터 만들어진다. 이들 복합 데이터형 중에서 가장 복잡한 것은 클래스이다.  
C++는 C로부터 가져온 몇 가지 다른 복합형들도 제공한다. 예를 들어, 배열(array)은 동일한 데이터형의 값 여러 개를 연속적으로 저장할 수 있다. 어떤 특정한 종류의 배열은 무자열 즉, 연속된 문자들을 저장할 수 있다. 구조체(structure)는 종류가 다른 여러 데이터형의 값을 함께 저장할 수 있다. 또한 포인터(pointer)라는 것이 있다. 포인터는 데이터가 저장되어 있는 주소를 컴퓨터에게 알려 주는 변수이다. 이번 단원에서는 클래스를 제외한 모든 복합형들에 대해 알아본다. 또한 new와 delete를 처음으로 살펴보고, 그들을 사용하여 데이터를 다루는 법을 알아본다. 그리고 문자열을 다루는 또 다른 방법인 C++의 string클래스르 간단하게 알아본다.
<hr> 

# 1. 배열
배열(array)은 데이터형이 같은 여러 개의 값을 연속적으로 저장할 수 있는 데이터 구조이다.  
배열은 선언 구문을 사용하여 생성한다. 배열 선언 구문에서는 다음과 같은 세 가지를 선언한다.
<ul type = square>
<li> 각 원소에 저장될 값의 데이터형</li>
<li> 배열의 이름</li>
<li> 배열 원소의 개수</li>
</ul>

C++에서는 간단한 변수의 선언 형식을 수정하여 배열을 선언한다. 즉, 배열 원소의 개수를 대괄호 안에 넣어 선언한다.
```
short months(12);       // 12개의 short형 값을 넣을 수 있는 배열을 생성
```
위의 코드는 배열의 이름이 months이고, 12개의 원소를 가지며, 각 원소에는 short형 값을 저장할 수 있다는 것을 나타낸다. 배열의 각 원소는 개별적으로 간단한 변수처럼 취급할 수 있는 변수이다.  
  
다음은 배열을 선언하는 일반적인 형식이다.
```
typeName arrayName(arraySize);
```
원소의 개수를 나타내는 arraysize는 값 10 또는 const 기호 상수와 같은 정수 상수이거나, 또는 컴파일할 때 값이 결정되는 8 * sizeof(int)와 같은 상수 수식이어야 한다. 특히 프로그램이 실행되는 동안에 값이 결정되는 변수는 arraySize가 될 수 없다. 그러나 new 연산자를 사용하여 이러한 제약을 피하는 방법도 있다.  
  
배열이 여러 가지 용도로 유용한 것은 각각의 배열 원소에 개별적으로 접근할 수 있기 때문이다. 개별적인 접근을 허용하기 위해 인덱스(subscript) 또는 인덱스(index)를 사용하여 배열 원소에 차례로 번호가 매겨진다. C++의 배열 인덱스는 항상 0부터 시작한다. 그리고 C++는 대괄호 안에 인덱스를 넣어 배열 원소를 지정한다.  
  
Listing 4.1은 배열을 선언하고, 배열 원소에 값을 대입하며, 배열을 초기화하는 것과 같은 배열에 관련된 몇 가지 사항을 보여준다.
```
// Listing 4.1
// arrayone.cpp

#include <iostream>
int main()
{
    using namespace std;
    int yams[3];                // 3개의 원소를 가진 배열을 선언
    yams[0] = 7;                // 첫 번째 원소에 값을 대입
    yams[1] = 8;
    yams[2] = 6;

    int yamcosts[3] = {200, 300, 50};   // 배열을 생성하고 초기화
    // 참고: 사용하는 C++ 컴파일러나 번역기가 이 배열을 초기화할 수 없다면
    // int yamcosts[3] 대신에 static int yamcosts[3]을 사용하라

    cout << "고구마 합계 = ";
    cout << yams[0] + yams[1] + yams[2] << endl;
    cout << yams[1] << "개가 들어 있는 포장은 ";
    cout << "개당 " << yamcosts[1] << "원씩입니다.\n";
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    total = total + yams[2] * yamcosts[2];
    cout << "세 포장의 총 가격은 " << total << "원입니다.\n";
    cout << "\nyams 배열의 크기는 " << sizeof yams;
    cout << "바이트입니다.\n";
    cout << "원소 하나의 크기는 " << sizeof yams[0];
    cout << "바이트입니다.\n";
    return 0;
}
```

### 프로그램 분석
Listing 4.1 프로그램은 3개의 원소를 가진 yams라는 배열을 생성한다. yams는 원소가 3개인 배열이므로 배열 원소들의 인덱스는 0, 1, 2가 된다.  
위 코드는 yams배열의 세 원소에 고지식한 방법으로 값을 대입하고 있다. 그러나 이렇게 하지 않고 선언 구문에서 배열 원소를 직접 초기화할 수도 있다. Listing 4.1은 yamcosts 배열에 이 방법으로 값을 대입하고 있다.
```
int yamcosts[3] = {200, 300 ,50};
```
이 방법은 배열 원소에 대입할 값들을 콤마로 구분하여 중괄호로 묶은 초기화 리스트를 간단하게 제공한다. 중괄호 안의 리스트에 빈칸이 있어도 되고 없어도 된다. 함수 안에서 정의된 배열을 초기화 하지 않으면, 배열 원소의 값들은 미확정 상태로 남는다. 즉, 배열 원소들은 그 메모리 위치에 전부터 우연히 남아있던 쓰레기 값들로 취한다.  

그리고 배열 원소들의 산술연산을 진행하였는데 인덱스와 대괄호의 사용 때문에 무척 고지식해 보인다. 하지만 아직 for문이나 while문에 대해 공부하지 않았으므로 이번 단원에서는 위와 같이 작성하였다.  
  
기억을 되살리면 sizeof 연산자는 데이터형이나 데이터 객체의 크기를 바이트 단위로 리턴한다. 배열 이름에 sizeof 연산자를 적용하면 그 배열의 전체 크기가 바이트 단위로 리턴된다. 그러나 배열 원소에 sizeof 연산자를 적용하면 배열 원소의 크기를 바이트 단위로 리턴한다.
  
## 배열 초기화 규칙

C++는 배열을 초기화하는 데 몇 가지 규칙을 적용하고 있다. 이 규칙은 배열 초기화를 할 수 있는 시기를 제한한다. 또한 배열 원소의 개수와 초기화 리스트에 제시된 값의 개수가 일치하지 않을 때 어떻게 할 것인지를 결정한다.
초기화 형식은 배열을 정의하는 곳에서만 사용할 수 있다. 초기화를 나중에 할 수는 없다. 배열을 다른 배열에 통째로 대입할 수도 없다.
```
int cards[4] = {3, 6, 8, 10}        // 맞다.
int hand[4];                        // 맞다.
hand[4] = {5, 6, 7, 8}              // 틀리다.
hand = cards;                       // 틀리다.
```
그러나 인덱스를 사용하여 배열 원소에 개별적으로 값을 대입하는 것은 언제든지 가능하다. 배열을 초기화할 때, 초기화 값의 개수를 배열 원소의 개수보다 모자라게 제공할 수도 있다.
```
float arr[5] = {5.0, 2.5};
```
배열을 부분적으로 초기화하면 컴파일러는 나머지 원소들을 자동으로 0으로 설정한다. 따라서 zeros와 같은 원소가 모두 0인 행렬은 배열의 첫 번째 원소만 0으로 초기화 시키면 간단하게 만들 수 있다.
```
long zeros[500] = {0};
```
배열을 초기화할 때 대괄호 속을 비워두면, 컴파일러가 초기화 값의 수를 헤아려 배열 원소의 개수를 결정한다.
```
short things[] = {1, 2, 3, 4};
```
배열 원소의 수가 4개인 short형의 배열 things를 생성한다.
<hr>

# 2. 문자열
문자열(string)이란 메모리에 바이트 단위로 연속적으로 저장되어 있는 문자들을 말한다. C++는 두 가지 방법으로 문자열을 처리한다. 첫 번째는 C로부터 유래한 C 스타일의 문자열 처리 방법으로, 이 단원에서는 이 방법을 먼저 알아본다. 또 다른 방법은 단원의 뒤에서 알아본다.  
  
문자들이 메모리에 바이트 단위로 저장된다는 것은, 문자열을 char형의 배열에 저장할 수 있다는 것을 의미한다. 이때 문자열을 구성하는 각 문자들은 배열의 원소에 하나씩 저장된다.  
C 스타일의 문자열은 특별한 특징을 가지고 있다. 모든 문자열의 마지막 문자가 반드시 널 문자(null character)여야 한다는 것인데 널 문자는 \0로 쓰며, ASCII 코드가 0인 문자이다. 그것은 문자열의 끝을 표시한다. 다음 두 구문을 비교해보자.
```
char dog[8] = {'b', 'e' , 'a', 'u', 'x', ' ', 'I', 'I'};    // 문자열이 아니다.
char cat[8] = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};    // 문자열이다.
```
두 배열이 모두 char형의 배열이다. 그러나 두 번째 배열만이 문자열이다. 널 문자는 C스타일의 문자열에서 중요한 역할을 한다. 예를 들어 C++는 cout이 사용하는 함수들도 포함하여, 많은 문자열 처리 함수를 가지고 있다. 이 함수들은 널 문자를 만날 때까지 문자 단위로 문자열을 처리한다. 앞에 예로 든 cat문자열을 cout으로 출력하면, 8개의 문자를 출력하고 나서 널 문자를 만나면 출력을 중단한다.<br><br>

그러나 앞의 예에서 문자열이 아닌 dog를 cout으로 출력하면, 배열에 들어 있는 5개의 문자를 모두 출력한 뒤에도 그 이후의 메모리 내용을 한 바이트씩 문자로 간주하여 계속해서 출력한다. 출력은 우연히 널 문자를 만날 때까지 이어진다. 그러나 값이 0으로 설정되는 널 문자들은 메모리에 아주 흔하기 때문에, 출력이 그렇게 오래 지속되지는 않는다.<br><br>

앞의 예에서 문자열을 하나하나 작은 따옴표로 묶어 콤마로 구분하는 일은 매우 귀찮은 일이었다. 이보다 좋은 방법은 char형의 배열을 문자열로 초기화하는 것이다.
```
char bird[11] = "Mr.Cheeps"     // \0을 저장한다.
char fish[] = "Bubbles"         // 컴파일러가 알아서 처리한다.
```
위와 같이 큰 따옴표로 묶인 문자열을 문자열 상수(string constant 또는 string literal)이라 한다. 큰 따옴표로 묶인 문자열은 끝내기 널 문자를 암시적으로 갖고 있다. 그러미로 문자열의 끝에 널 문자를 명시적으로 넣을 필요가 없다.

```
char shirt_size = 'S';
char shirt_size = "S";
```
위 두 코드를 보자. 첫 코드의 'S'는 문자 상수 83을 의미하며 프로그램에서 실행하게 되면 문제가 발생하지 않는다. 두 번째 코드의 "S"는 내부적으로 문자열이 저장되어 있는 메모리 주소를 나타내며 코드는 char형 변수에 메모리 주소를 대입하는 코드이다. 메모리 주소와 char형은 다른 종류의 데이터형이기 때문에 에러가 발생한다. 이에 대해서는 뒤에 포인터를 다룰 때 더 알아보도록 하자.<br>

## 문자열 상수의 결합
어떤 문자열은 너무 길어서 한 행으로 표현할 수 없다. 이러한 경우에 C++에서는 문자열 상수들을 결합할 수 있다. 즉, 큰 따옴표로 묶인 두 문자열을 하나로 결합할 수 있다. 빈칸, 탭, 캐리지 리턴과 같은 화이트 스페이스(white space)로 분리된 두 개의 문자열 상수는 하나의 문자열 상수로 결합된다.
```
cout << "I'd give my right arm to be a great violinist.\n";
cout << "I'd give my right arm to be" "a great violinist.\n";
cout << "I'd give my right ar" "m to be a great violinist.\n"
```
위 세 개의 출력 구문은 모두 동일하다. 이때 결합된 문자열에는 어떠한 빈칸도 추가되지 않는다. \0을 뺀 첫 번째 문자열의 마지막 문자에 두 번째 문자열의 첫 문자가 이어진다. 즉, 첫 번째 문자열의 \0가 두 번째 문자열의 첫 문자로 대체된다.<br>

## 배열에 문자열 사용
배열에 문자열을 넣는 가장 일반적인 방법은 두 가지이다. 배열을 문자열 상수로 초기화하는 방법과, 키보드 입력이나 파일 입력을 배열에 저장하는 방법이다. Listing 4.2는 큰 따옴표로 묶인 문자열로 배열을 초기화하는 방법과, cin을 통해 키보드로 입력한 문자열을 배열에 저장하는 방법을 설명한다. 이 프로그램은 문자열의 길이를 알아내기 위해 표준 라이브러리 함수 strlen()을 사용한다. cstring 표준 헤더 파일은 이 함수를 포함하여, 다른 많은 문자열 관련 함수들의 선언을 제공한다.
```
// Listing 4.2
// strings.cpp

#include <iostream>
#include <cstring>  // strlen() 함수를 사용하기 위해
int main()
{
    using namespace std;
    const int Size = 15;
    char name1[Size];       // 빈 배열
    char name2[Size] = "C++owboy";      // 문자열 상수로 초기화된 배열
    // 참고: 어떤 C++에서는 name2 배열을 초기화하기 위해
    // static 키워드를 사용해야 한다.

    cout << "안녕하세요! 저는 " << name2;
    cout << "입니다! 실례지만 성함이?\n";
    cin >> name1;
    cout << "아, " << name1 << "씨! 당신의 이름은 ";
    cout << strlen(name1) << "자입니다만 \n";
    cout << sizeof(name1) << "바이트 크기의 배열에 저장되었습니다.\n";
    cout << "이름이 " << name1[0] << "자로 시작하는군요.\n";
    name2[3] = '\0';            // null
    cout << "제 일므의 처음 세 문자는 다음과 같습니다: ";
    cout << name2 << endl;
    return 0;
}
```
### 프로그램 분석
Listing 4.2에서 우리는 무엇을 배울 수 있을까? 먼저 sizeof 연산자가 배열의 전체 크기를 15바이트라고 알려준다. 그러나 strlen() 함수는 배열의 전체 크기가 아니라 배열에 저장된 문자열의 크기를 리턴한다. strlen()함수는 널문자는 제외하고 눈에 보이는 문자들만 헤아려 Basicman의 길이로 9가 아닌 8을 리턴한다. 일반적으로 cosmic이 문자열이라면, 그 문자열을 저장할 수 있는 배열의 최소 크기는 strlen(cosmic) + 1이다.<br><br>
Listing 4.2 프로그램은 배열 크기를 기호 상수로 나타내고 있다. 배열 크기는 프로그램의 여기저기에 흩어져 있는 여러 구문에서 사용되는 경우가 많다. 배열 크기를 기호 상수로 나타내면, 나중에 배열 크기를 바꾸어야 할 때 프로그램을 수정하기가 쉽다. 기호 상수가 정의된 곳에서 한 번만 값을 바꾸면 된다.<br><br>
## 문자열 입력
Listing 4.2에서 발생하는 결함을 Listing 4.3을 통해 알아보고 문자열 입력이 쉽지 않을 수 있다는 것을 보여준다.
```
// Listing 4.3
// instr1.cpp
#include <iostream>
int main()
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    cout << "이름을 입력하십시오: \n";
    cin >> name;
    cout << "좋아하는 디저트를 입력하십시오: \n";
    cin >> dessert;
    cout << "맛있는 " << dessert;
    cout << "디저트를 준비하겠습니다. " << name" << "님!\n";
    return 0;
}
```
Listing 4.3 프로그램의 의도는 단순하다. 사용자의 이름과 좋아하는 디저트를 키보드로 입력받아 그 정보를 화면에 다시 출력하는 것이다.<br>
이 프로그램은 디저트를 입력하라는 프롬프트에 응답할 수 있는 기회를 주지 않는다. 디저트를 입력하라는 프롬프트를 출력한 다음, 멈추지를 않고 곧 바로 마지막 줄까지 출력해 버리기 때문이다.<br><br>
이렇게 되는 이유는 cin이 문자열의 끝을 인식하는 방법 때문이다. 키보드로는 끝내기 널 문자를 입력할 수 없기 때문에, cin에게 문자열의 끝을 알려주는 다른 수단이 필요하다. 그렇기 때문에 cin은 빈칸, 탭, 캐리지 리턴과 같은 화이트 스페이스가 있으면 그 위치에서 문자열이 끝난 것으로 간주한다. 즉, char형의 배열에 저장하기 위해 키보드로부터 입력을 받을 때 cin은 하나의 단어만 읽어 그것을 배열에 저장하고 널 문자를 끝에 추가한다.<br><br>
## 한 번에 한 행의 문자열 입력 읽기
한 번에 한 단어씩 문자열 입력을 읽는 것은 바람직한 선택이 아니다. 예를 들어 프로그램이 사용자에게 도시 이름을 입력할 것을 요청하고, 사용자가 ***New York, Sao Paulo***라고 응답한다고 가정하자. 이러한 경우에 사용자는 프로그램이 New, Sao만이 아닌 전체를 읽기를 원할 것이다. 이를 문자열로 입력하려면 다른 방법이 필요하다. 즉, 단어 단위의 문자열 입력이 아닌, 행 단위의 문자열 입력이 필요하다. 다행히 istream 클래스가 행 단위로 문자열을 입력하는 클래스 멤버 함수인 getline()과 get()을 제공한다. 둘 다 전체 입력 행을 읽는다. 즉, 개행 문자가 나올 때까지 읽는다. 그러나 getline()은 개행 문자를 읽어서 폐기하는 반면에 get()은 입력 큐에 개행 문자를 남겨둔다. getline()부터 시작하여 알아보자.<br><br>
### getline()을 이용한 행 단위 입력
getline()함수는 Enter키에 의해 전달되는 개행 문자를 입력의 끝으로 간주하여 한 행 전체를 읽는다. cin.getline()을 함수 호출로 사용함으로써 이 메서드를 호출할 수 있다. 이 함수는 두 개의 매개변수를 사용한다. 첫 번째 매개변수는 입력한 행을 저장할 배열의 이름이다. 두 번째 매개변수는 입력받을 문자들의 한계이다. 한계가 20이면 이 함수는 최대 19개까지 문자들을 입력받을 수 있다. 나머지 한 자리는 널 문자를 위해 예비해 두는 것이다. getline()멤버 함수는 한계에 도달하거나 한계 이전이라도 개행 문자를 읽으면 읽기를 중단한다.<br><br>
예를 들어, getline() 함수로 이름을 읽어 20개의 원소를 가진 name 배열에 저장하고 싶다면 다음과 같은 호출을 사용할 수 있다.
```
cin.getline(name, 20);
```
이 구문은 한 행 전체를 읽어, name 배열에 저장한다. 이때 그 행에 있는 문자들의 개수는 최대 19개 또는 그보다는 적어야 한다. Listing 4.4는 Listing 4.3을 cin 대신에 cin.getline()을 사용하도록 수정한 것이다.
```
// Listing 4.4
// instr2.cpp
#include <iostream>
int main()
{
    using namespace std;
    const int ArSize = 20;
    char name[ArSize];
    char dessert[ArSize];

    cout << "이름을 입력하십시오: \n";
    cin.getline(name, ArSize);
    cout << "좋아하는 디저트를 입력하십시오: \n";
    cin.getline(dessert, ArSize);
    cout << "맛있는 " << dessert;
    cout << "디저트를 준비하겠습니다. " << name" << "님!\n";
    return 0;
}
```
이 프로그램은 이름이 빈칸으로 분리되어 있어도 온전하게 하나로 읽는다. 또한 좋아하는 디저트를 입력할 기회도 준다. getline()함수는 편리하게 한 행을 한 번에 읽는다. 이 함수는 행의 끝을 표시하는 개행 문자까지 읽는다. 그러나 개행 문자는 저장하지 않는다. 개행문자는 널 문자로 대체하여 저장한다.

### get()을 이용한 행 단위 입력
istream 클래스는 또 다른 멤버 함수인 get()을 제공한다. 이 함수는 여러 변종이 있다. 그중의 하나가 getline() 함수처럼 동작한다. 그것은 같은 매개변수를 사용하고, 매개변수를 같은 방식으로 해석하며, 행의 끝까지 읽는다. 그러나 이 함수는 개행 문자를 읽어서 버리지 않고 입력 큐에 그대로 남겨둔다. get()을 연달아 두 번 호출한다고 가정해보자.
```
cin.get(name, ArSize);
cin.get(dessert, ArSize);       // 문제 발생
```
첫 번째 호출이 입력 큐에 개행 문자를 그대로 남겨 두기 때문에, 두 번째 호출은 그 개행 문자를 첫 문자로 만나게 된다. 그래서 get()은 읽을 것도 없이 곧 바로 행의 끝에 도달했다고 결론을 내린다. 따라서 특별한 조치를 취해 주지 않는 한 get()은 개행 문자를 넘어갈 수가 없다.<br><br>
다행히 get()의 한 변종으로부터 도움을 받을 수 있다. cin.get()호출은 그것이 개행 문자이든 아니면 다른 무엇이든 간에 무조건 문자 하나를 읽는다.
```
cin.get(name, ArSize);          // 첫 번째 행을 읽는다.
cin.get();                      // 개행 문자를 읽는다.
cin.get(dessert, ArSize);       // 두 번째 행을 읽는다.
```
get()을 사용하는 또 한 가지 방법은 두 개의 클래스 멤버 함수를 결합하여 사용하는 것이다. 즉, 다음과 같이 사용한다.
```
cin.get(name, ArSize).get();        // 멤버 함수들을 결합한다.
```
이와 같이 사용하면 cin.get(name, ArSize)가 cin객체를 리턴한다. 리턴된 cin 객체는 뒤에 결합된 get() 함수를 호출하는 객체로 사용된다. 이와 비슷한 원리로
```
cin.getline(name1, ArSize).getline(name2, ArSize);
```
두 행의 입력을 연속해서 읽어 name1과 name2 배열에 각각 저장한다. 이것은 cin.getline()을 두 번 호출하는 것과 같다.
