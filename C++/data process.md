# 데이터 처리
객체 지향 프로그래밍(OOP)의 진수는 사용자가 데이터형을 스스로 설계하고 확장할 수 있다는 데에 있다. C++에 내장된 데이터형에는 기본형과 복합형이 있다. 오늘은 기본형에 대해서만 알아본다. 기본형에는 정수를 표현할 수 있는 정수형과, 소수부가 있는 수를 표현할 수 있는 부동 소수점형이 있다. 언뜻 들으면 두 가지 데이터형만 있는것처럼 들리지만, 하나의 정수형과 하나의 부동 소수점형만 가지고는 모든 프로그래밍 상황에 대처할 수 없기 때문에 필요에 따라 골라 쓸 수 있는 여러 가지 변형 데이터형이 이들을 기초로 하여 만들어져 있다.  
  
* ## 간단한 변수
컴퓨터에 정보를 저장하려면 다음 세 가지 사항을 알아야 한다.
* 어디에 저장되는가?
* 어떤 값이 저장되는가?
* 어떤 종류의 정보인가?
이제까지 변수 선언으로 정보를 저장해왔다. 변수 선언에 나오는 데이터형은 정보의 종류를 나타내고, 변수 이름은 그 값을 기호로 나타낸 것이다. 다음과 같은 구문을 사용한다고 가정해보자.
```
int braincount;
braincount = 5;
```
이 구문은 하나의 정수를 저장할 것이며, braincount라는 이름이 그 정수의 값, 즉 5를 나타낸다고 프로그램에게 알려준다. 이 구문만 보고는 그 값이 메모리의 어디에 저장되는지 알 수 없다. 그러나 프로그램은 그 위치를 추적할 수 있다. 사용자도 &연산자를 사용하면 braincount의 메모리 주소를 알아낼 수 있다.  
* ### 변수 이름
C++에서는 의미를 쉽게 알 수 있는 변수 이름을 사용할 것을 권장한다. 어떤 변수가 여행 비용을 나타낸다면, 변수 이름을 x나 cot로 하지말고, cost_of_trip 또는 costOfTrip으로 해야한다. C++에서 변수 이름을 지을 때에는 다음과 같은 간단한 규칙을 따라야 한다.
* 변수 이름에는 영문자, 숫자, 밑줄 문자만을 사용할 수 있다.
* 숫자를 변수 이름의 첫 문자로 사용할 수 없다.
* 변수 이름에서 대문자와 소문자는 구별된다.
* C++의 키워드는 변수 이름으로 사용할 수 없다.
* 두 개의 밑줄 문자로 시작하는 이름이나, 밑줄 문자와 대문자로 시작하는 이름은 그것을 사용하는 컴파일러와 리소스가 사용하기로 예약이 되어있다. 하나의 밑줄 문자로 시작하는 이름은, 그것을 사용하는 컴파일러와 리소스가 전역 식별자(global identifier)로 사용하기로 예약되어 있다.
* 변수 이름의 길이는 제한이 없으며, 변수 이름에 쓰인 모든 문자들이 유효하다. 그러나, 어떤 플랫폼은 고유의 길이 제한이 있다.  
  
뒤에서 두 번째 규칙은 __time_stop 또는 _Dount같은 이름을 사용해도 컴파일러 에러가 발생하지 않고, 정의되지 않는 이상한 동작을 일으킨다는 뜻에서 앞의 네 가지 규칙과는 성격이 조금 다르다. 컴파일러 에러가 발생하지 않는 이유는 이름은 적법하지만 컴파일러가 사용하기로 예약되어 있기 때문이다. 전역 이름에 사용된 하나의 밑줄 문자는 그 이름이 전역적으로 선언된 것임을 알려준다.  
  
다음은 C++의 변수 이름으로 맞는 것과 틀리는 것의 예이다.
```
int poodle;         // 맞다
int Poodle;         // 맞다. poodle과 구별된다
int POODLE;         // 맞다. poodle과 더 확실히 구별된다.
Int terrier;        // 틀리다. Int가 아니라 int가 맞다.
int my_stars3;      // 맞다
int _Mystarts3;     // 맞다. 예약 _밑줄문자로 시작하므로
int 4ever;          // 틀리다. 숫자로 시작할 수 없다.
int double;         // 틀리다. double은 C++ 키워드이므로
int begin;          // 맞다. begin은 Pascal 키워드 이므로 상관없다.
int __fools;        // 맞다. 예약 두 개의 밑줄 문자로 시작하므로
int the_very_best_variable_i_can_be_version_112;    // 맞다
int honky-tonk;     // 틀리다. 하이픈을 사용할 수 없다
```
두 개 이상의 단어를 결합하여 변수 이름을 지을 때에는 my_options와 같이 밑줄로 단어를 구분하거나, myEyeTooth와 같이 첫 단어를 제외하고 각 단어들의 첫 문자를 대문자로 쓰는것이 관례이다.
* ### 정수형
정수는 소수부가 없는 수를 뜻한다. 그런데 컴퓨터의 메모리 용량에는 한계가 있으므로 무한하게 많은 정수를 컴퓨터로 모두 나타낼 수는 없다. 따라서 컴퓨터 언어는 정수들의 부분 집합만을 나타낼 수 있다. C++는 여러 가지 정수형을 제공한다. 이것은 프로그램이 요구하는 특정 상황에 가장 알맞은 정수형을 골라 사용할 수 있도록 하기 위해서이다. 
 
C++의 여러 정수형들은 서로 다른 크기의 메모리를 사용하여 정수를 저장한다. 메모리 블록이 클수록 나타낼 수 있는 정수값의 범위가 크다. signed 데이터형은 양수값과 음수값을 모두 나타낼 수 있으나, unsigned 데이터형은 양수값만 나타낼 수 있다. 정수를 저장하는 데 사용되는 메모리의 크기를 폭(width)이라 한다. 메모리 크기가 클수록 폭이 넓다. C++의 기본 정수형을 크기 순서로 나열하면  
```
char < short < int < long < longlong(C++ 11)
```
의 순서이다. 이 기본형들에 대해 signed형과 unsigned형이 각각 따로 존재한다. 그러므로 모두 합하여 여덟 가지의 기본형이 있는 셈이다. 이제 이 정수형들을 자세히 살펴보자

* ## short, int ,long, long long
컴퓨터의 메모리는 비트라는 단위로 이루어진다. C++에서 short, int, long은 정수를 저장하는데 사용하는 비트 수가 다르다. 따라서 이들은 각각 폭이 다른 세 가지 정수 범위를 나타낼 수 있다. 예를 들면 short형은 언제나 16비트, int형은 언제나 32비트, 이런 식으로 모든 C++에서 동일한 데이터형이 동일한 폭을 갖는다면 매우 편리할 것이다. 그러나 세상ㅇ은 말처럼 그렇게 단순하지가 않다. 모든 컴퓨터를 만족시킬 수 있는 탁월한 선택은 없다. 그래서 C++는 이 데이터 형들의 최소 크기만을 정하여 보다 융통성 있는 표준을 제공한다.
* short형은 최소한 16비트 폭을 가진다.
* int형은 최소한 short만큼은 크다.
* long형은 최소한 32비트 폭을 가지며, 최소한 int만큼은 크다.
* long long형은 최소한 64비트 폭을 가지며, 최소한 long만큼은 크다.  
기존 int형 변수를 선언했던것과 같이 다른 데이터형들의 변수도 선언이 가능하다.  
```
short score;        // short형의 정수형 변수를 만든다.
int temperature;    // int형의 정수형 변수를 만든다.
long position;      // long형의 정수형 변수를 만든다.
```
여기서 short는 short int를 줄인것이고, long은 long int를 줄인 것이다. 대부분의 프로그래머가 이와 같이 줄인 표현을 사용한다.  
  
사용하는 C++시스템의 정수 크기가 얼마인지 알고 싶으면 첫 번째 방법은 크기를 알아내는 도구인 
```
sizeof
```
연산자를 사용하여 알 수 있다. sizeof 연산자는 변수나 데이터형의 크기를 바이트 단위로 리턴한다.  
  
두 번째 방법은 여러 가지 정수형들의 범위에 대한 정보가 들어 있는 climits헤더 파일을 열어 보는 것이다. 이 파일은 여러 정수형들의 서로 다른 한계값을 기호 이름으로 정의하고 있다. 예를 들면 int형의 최대 값을 INT_MAX, char형의 비트 수를 CHAR_BIT로 정의하고 있다. Listing 3.1은 이것을 사용하는 방법을 보여준다.
```
// Listing 3.1
// limits.cpp
#include <iostream>
#include <climits>  // 구식 C++에는 limits.h를 사용한다.

int main()
{
    using namespace std;
    int n_int = INT_MAX;    // n_int를 int형의 최대값으로 초기화
    short n_short = SHRT_MAX;   // limits.h 파일에 정의된 기호 상수
    long n_long = LONG_MAX;
    long long n_llong = LLONG_MAX;

    // sizeof 연산자는 데이터형이나 변수의 크기를 알아낸다.
    cout << "int는 " << sizeof (int) << " 바이트이다." << endl;
    cout << "short는 " << sizeof n_short << " 바이트이다." << endl;
    cout << "long는 " << sizeof n_long << " 바이트이다." << endl;
    cout << "long long는 " << sizeof n_llong << " 바이트이다." << endl;
    cout << endl;

    cout << "최대값: " << endl;
    cout << "int: " << n_int << endl;
    cout << "short: " << n_short << endl;
    cout << "long: " << n_long << endl;
    cout << "long long: " << n_llong << endl; << endl;
    cout <<"int의 최솟값 = " << INT_MIN << endl;
    cout << "바이트 당 비트 수 = " << CHAR_BIT << endl;
    return 0;
}
```
다음은 Listing 3.1의 출력 예시이다.
```
int는 4 바이트이다.
short는 2 바이트이다.
long는 4 바이트이다.
long long는 8 바이트이다.

최대값:
int: 2147483647
short: 23767
long: 2147483647
long long: 9223372036854775807

int의 최솟값 = -2147483648
바이트 당 비트 수 = 8
```
