# C++ 시작
하나의 메시지를 출력하는 간단한 C++ 프로그램을 통해서 C++로의 긴 여행을 떠나보자.
Listing 2.1은 C++의 cout 기능을 사용하여 문자를 출력하고 있다.  
C++의 주석문은 //로 시작한다. 컴파일러는 주석문을 무시하고 건너뛴다. C++은 대, 소문자를 구별한다. 따라서 cout을 Cout이나 COUT으로 표기하게되면 컴파일러가 알 수 없다.  
```
// myfirst.cpp
#include <iostream>         // 선행처리 지시자
int main(){                 // 함수 머리, 함수 몸체의 시작
    using namespace std;    // 정의 가시화
    cout << "Welcome C++";  // 메시지 출력
    cout << endl;           // 새로운 행 시작
    cout << "My first C++" << endl; // 또 다른 메시지 출력
    return 0;               // main()을 종료
}                           // 함수 몸체의 끝
```  

main 함수의 역할을 살펴보면 main() 앞에 오는 전처리 지시자와 같은 것들을 이해하기가 더 쉽기 떄문에, main() 함수가 무엇을 하는지부터 알아보자.
* ## main() 함수
군더더기를 떼어버리면 Listing 2.1은 다음과 같은 기본 구조로 되어 있다.
```
int main()
{
    구문들
    return 0;
}
```  
이것을 살펴보면 main() 이라는 함수가 있다는 사실과, 그 함수가 어떠한 동작을 처리하는 것인지 알 수 있다. 이것은 두 부분으로 이루어져 있는데 이들이 함수 정의(function definition)을 구성한다. 첫 번째 행에 있는 int main()이라는 부분이 함수 머리(function header)이고, 중괄호({})로 묶여 있는 부분이 함수 몸체(function body)이다. 함수 머리는 이 함수를 프로그램의 다른 부분과 연결하는 고리 역할을 하고, 함수 몸체는 그 함수가 처리하는 동작들을 컴퓨터에게 지시하는 역할을 한다. 컴퓨터에게 내리는 지시(instruction)를 구문(statement)이라고 하는데 C++에서 모든 구문은 세미콜론으로 끝나야 한다.  
main() 함수의 끝에 있는 구문은 return 구문이다. 이것은 함수를 종료하는 역할을 한다. return 구문에 대해서는 나중에 다시 알아보자.

* ## 인터페이스 역할을 하는 함수 머리
main() 함수의 정의가 함수 머리 int main()으로부터 시작한다는 사실을 알아보았다. 함수 머리의 문법에 대해 조금 알아보자.  
일반적으로 함수는 다른 함수에 의해 호출된다. 이때 함수 머리는 호출 함수와 피호출 함수의 인터페이스를 나타낸다. 함수 이름의 앞부분을 함수 리턴형(function return type)이라고 한다. 이것은 피호출 함수가 호출 함수로 다시 넘겨주는 정보의 흐름을 나타낸다. 함수 이름 뒤에 있는 괄호 한의 부분을 인자 리스트(argument list) 또는 매개변수 리스트(parameter list)라고 한다. 이것은 호출 함수가 피호출 함수로 넘겨주는 정보의 흐름을 나타낸다. 이러한 일반 규칙이 main() 함수에서는 다소 혼동된다. 그 이유는 프로그램 어디에도 main() 함수를 호출하는 부분이 없기 때문이다. 일반적으로 main()은, 프로그램과 운영체제를 중개하기 위해 컴파일러가 프로그램에 추가하는 시동코드에 의해 호출된다. 따라서 이 함수 머리는 main()과 운영 체제 사이의 인터페이스를 나타낸다.  
main()을 위한 인터페이스를 살펴보자. 먼저 int 부터 보자. 다른 함수에 의해 호출된 함수는 자신을 호출한 함수에게 값을 리턴할 수 있다. 이 값을 리턴값(return value)이라 한다. 앞의 예제에서 main() 함수는 정수값을 리턴할 수 있다. 키워드 int를 보고 이 사실을 알 수 있다.  
다음은 빈 괄호에 대해 알아보자. 일반적으로 어떤 함수가 다른 함수를 호출할 때 정보도 함께 전달할 수 있다. 함수 머리의 괄호 안에 있는 부분이 이 정보를 나타낸다. 이 예제의 경우에 괄호 안이 비어 있는 것은 main() 함수가 어떤 정보도 전달받지 않는다는 것을 뜻한다. 이것을 프로그래밍 전문 언어로 말하면, main()이 어떠한 parameter도 요구하지 않는다는 것을 의미한다.  
간단히 말해, 다음과 같은 함수 머리는  
```
int main()
```  

main() 함수가 자신을 호출한 함수로부터 어떠한 정보도 전달받지 않지만, 그 함수에게 정수값을 리턴한다는 것을 나타낸다.  
많은 기존의 프로그램들이 클래식C의 함수 머리를 사용하고 있다.
```
main()  // 클래식 C의 함수 머리 스타일
```  
클래식 C에서, 리턴형을 생략하는 것은 그 함수가 int형이라고 말하는 것과 같다. 그러나 C++는 이와 같은 용법을 폐기했다. 또한 다음과 같이 사용할 수도 있다.
```
int main(void)  // 아주 명시적인 스타일
```  
괄호 안에 키워드 void를 사용하는 것은 그 함수가 다른 함수로부터 어떠한 것도 전달받지 않는다는 것을 명시적으로 밝히는 것이다. c++에서 괄호 안을 비워 두는 것은 괄호 안에 void가 있는 것과 같다.  
어떤 프로그래머들은 다음과 같은 스타일의 함수 머리를 사용하고 리턴 구문을 생략한다.
```
void main()
```  
void 리턴형이 함수가 값을 리턴하지 않는다는 것을 뜻하기 때문에, 이것은 논리적으로 타당하다. 그러나 이러한 스타일이 일부 시스템에서는 잘 동작하더라도, C++ 표준은 아니므로 어떤 시스템에서는 동작하지 않는다. 그러므로 이러한 스타일을 사용하는 것을 피하고 C++ 표준을 사용해야 한다. 그렇게 하는데 수고가 많이 드는 것도 아니다.  
끝으로 main()의 끝에 리턴 구문을 두어야 한다는 성가신 강요에 대해 불평하는 사람들에게 ISO C++ 표준은 한발 양보한다. 컴파일러가 리턴 구문을 만나지 못한채 main()의 끝에 도달하면 다음과 같은 구문으로 main()을 끝내는 것과 동일한 효과를 낸다.
```
return 0;
```  

* ## 이름이 반드시 main() 이어야 하는 이유
모든 C++ 프로그램은 maini() 함수로부터 실행을 개시한다. myfirst.cpp 프로그램에는 함수가 하나만 존재하므로 그 함수가 main() 함수의 역할도 해야 한다. 프로그램에 main() 함수가 없으면 완전한 프로그램이 아니다. 이러한 경우에 컴파일러는 main() 함수를 정의하지 않았다고 지적할 것이다.  
그러나 예외도 있다. 예를 들어 Windows 프로그래밍에서 동적 링크 라이브러리(DLL) 모듈을 작성할 때가 그렇다. DLL모듈은 다른 Windows 프로그램들이 사용할 수 있는 코드로서, 독립된 프로그램이 아니므로 main()이 필요 없다. 로봇의 컨트롤러 칩과 같은 특수한 환경에서는 main() 이 필요하지 않을 수도 있다. 그러나 일반적인 독립형 프로그램에는 반드시 main()이 필요하다.

* ## C++ 주석문
더블 슬래시(//) 뒤에는 항상 C++의 주석문이 온다. 주석문은 프로그래머가 프로그램 안에 기록해 두는 일종의 메모로, 프로그램의 구역을 구분하거나 코드의 어떤 부분이 무슨 역할을 하는 것인지 표시하는데 사용한다. 컴파일러는 이 주석문을 아예 무시하고, 주석문이 아닌 것만을 컴파일 하기 때문에 주석문의 내용을 결코 볼 수 없다. 결과적으로 Listing 2.1 프로그램은 컴파일러에게 다음과 같이 주석문 없이 작성된 것처럼 보인다.
```
#include <iostream>         
int main(){                 
    using namespace std;    
    cout << "Welcome C++";  
    cout << endl;           
    cout << "My first C++" << endl; 
    return 0;               
}                          
```  
C++의 주석문은 더블슬래시에서 그 행의 끝까지이다.

* ## C++ 전처리기와 iostream 파일
여기서 알아야 할 사항이 있다. C++의 일반적인 입출력 기능을 사용하려면 다음 두 행을 프로그램에 꼭 넣어야 한다.
```
#include <iostream>
using namespace std;
```  
위 두 번째 라인은 몇 가지 대체 방법이 있는데, 지금은 단순하게만 넘어간다.  
C와 마찬가지로 C++도 전처리기(preprocessor)를 사용한다. 전처리기는 컴파일을 하기 전에 소스 파일에 대해 미리 어떤 처리를 수행하는 프로그램이다.  
이름이 #로 시작되는 것은 전처리 지시자(directive)라고 부른다. 전처리기는 특별히 따로 호출하는 것이 아니라 소스 파일을 컴파일할 때 자동으로 실행된다.
```
#include <iostream> // 전처리 지시자
```  
이 지시자는 전처리기에게 iostream 파일의 내용을 프로그램에 추가하라고 지시한다. 이와 같이 컴파일 되기 전에 소스 코드에 텍스트를 추가하거나 텍스트를 대체하는 것이 전처리기가 수행하는 기본적인 역할이다.  
그런데 iostream파일의 내용을 왜 프로그램에 포함해야 할까? 그 이유는 프로그램과 바깥 에상이 정보를 주고받을 수 있도록 하기 위해서다. iostream의 i는 입력(input), o는 출력(output)을 나타낸다. iostream 파일에는 C++의 몇 가지 입출력 기능이 정의되어 있다. 프로그램에서 cout 가능을 사용하려면 이러한 정의가 필요하다 #include 지시자는 프로그램 안에 있는 #include <iostream\>이라는 행이 iostream 파일의 내용으로 대체된다. 사용자가 작성한 소스 파일은 변경되지 않은 채 그대로 유지되고, 소스 파일과 iostream의 결합 파일이 컴파일의 다음 단계로 넘어간다.

* ## 헤더 파일 이름
iostream과 같은 파일을 포함 파일(다른 파일에 포함된다는 의미에서), 또는 헤더 파일(파일의 앞부분에 들어간다는 의미에서)이라고 부른다. C++ 컴파일러는 많은 헤더 파일을 제공한다. 각각의 헤더 파일은 특정 부류의 기능을 지원한다. C에서는 헤더 파일의 이름만 보고도 파일 유형을 알 수 있도록 헤더 파일에 h 확장자를 사용했다. 예를 들어 C의 math.h 헤더 파일은 여러 가지 수학 함수들을 지원했다.  
C++의 헤더 파일에는 확장자를 사용하지 않는다. C 헤더 파일이 C++ 헤더 파일로 진화한 것도 있는데 그러한 헤더 파일들은 .h확장자를 빼고 이름의 앞부분에 c를 넣는다.

* ## 이름 공간
iostream.h 대신에 iostream을 사용할 때, 프로그램이 iostream의 정의를 사용할 수 있게 하려면 다음과 같은 이름 공간 지시자를 활용해야 한다.
```
using namespace std;
```  
이것을 using 지시자(directive)라 부른다는 정도만 알고 나중에 자세히 공부하도록 하자.  
이름 공간은 C++의 가장 새로운 기능이다. 이름 공간은 프로그램을 작성할 때 여러 소프트웨어 개발업체들이 제공하는 코드들을 사용할 수 있도록 도와준다. 예를 들어, 두 업체의 제품을 사용해야 하는데 두 제품에 모두 wanda()라는 함수가 들어 있다면, 컴파일러에는 어느 제품의 wanda()를 사용해야 할지 판단할 수 없게 된다. 이와 같은 경우에 한 업체의 패키지를 이름 공간(namespace)이라는 하나의 단위로 포장하여 나타낼 수 있다. 이를 테면 Microflop Industries라는 회사가 만든 제품에 대해서는 Microflop이라는 이름 공간으로 포장하여, 그 회사의 wanda() 함수에 Microflop::wanda()라는 이름을 사용한다. 다른 예로 Piscine Corporation 회사가 만든 wanda() 함수에 Piscine::wanda()라는 이름을 사용한다. 그러면 컴파일러는 두 가지 버전을 확실하게 구분할 수 있다.
```
Microflop::wanda("go dancing?");        // Microflop 이름 공간의 버전
Piscine::wanda("a fish named Desire");  // Piscine 이름 공간의 버전
```  
이러한 방식에 의해, C++ 컴파일러의 표준 구성 요소인 클래스, 함수 ,변수는 std라는 이름 공간 안에 담겨진다. 이와 같은 일은 .h 확장자가 없는 헤더 파일들 안에서 일어난다. 예를 들어, 이것은 출력하는데 사용되고 iostream 헤더 파일 안에 정의되어 있는 cout 변수가 실제로는 std::cout으로 호출되고, end이 실제로는 std::endl이라는 것을 의미한다. 그래서 사용자는 using 지시자를 생략하고 다음과 같은 스타일로 코드를 작성할 수 있다.
```
std::cout << "C++의 세계로 오십시오.";
std::cout << std::end;
```  
그러나 iostream.h와 cout을 사용하는 이름 공간 이전의 소스 코드를 iostream과 std::cout을 사용하는 이름 공간 소스 코드로 변환하는 일이 번거롭다면 대부분의 사용자들이 이러한 변환을 달가워하지 않을 것이다. 이때 사용하는 것이 using 지시자이다. 다음과 같은 행을 소스 코드에 넣으면 std:: 접두어를 붙이지 않고도 std이름 공간에 정의되어 있는 이름들을 사용할 수 있다.
```
using namespace std;
```  
using 지시자는 std 이름 공간에 들어 있는 모든 이름을 사용할 수 있게 해준다. 요즘에는 이 방식을 게으른 것으로 간주하고, using 선언이라는 것을 사용하여 자신에게 필요한 이름들만 선택해서 사용할 수 있게 다음과 같은 최신 방식을 선호한다.
```
using std::cout;    // cout을 사용할 수 있게 만든다
using std::endl;    // endl을 사용할 수 있게 만든다
using std::cin;     // cin을 사용할 수 있게 만든다
```  
std::를 cin과 cout에 직접 붙이지 않고, 아래와 같이 사용할 수도 있다.
```
using namespace std;    // 게으른 방식, 모든 이름을 사용할 수 있다.
```  
그러나 이 최신 방식에서 iostream에 들어 있는 이름들을 사용하려면, 그 다른 이름들을 using 리스트에 개별적으로 추가해야 한다.  
* ## cout을 이용한 C++의 출력
이제 메시지를 어떻게 출력하는지 알아보자. myfirst.cpp 프로그램은 메시지를 출력하는 다음과 같은 구문을 사용하고 있다.
```
cout << "Welcome C++";
```  
큰 따옴표 안에 들어 있는 부분이 출력할 메시지이다. C++ 에서는 큰 따옴표 안에 들어 있는 연속된 문자들을 문자열(string)이라고 부른다. 이것은 문자들이 끈처럼 하나로 이어져 보다 큰 단위를 이루고 있기 때문이다. << 표시는 구문이 그 문자열을 cout에 전달한다는 것을 뜻한다. << 표시가 나타내는 방향이 정보의 흐름을 상징한다. 그렇다면 cout은 무엇을 의미할까? cout은 문자열(string), 수(number), 문자(character)들을 포함한 여러 가지 다양한 정보들을 출력하는 방법을 알고 있는 미리 정의된 객체이다.  

* ## C++ 소스 코드의 모양
FORTRAN 과 같은 프로그래밍 언어에서는 하나의 구문이 하나의 행을 차지한다. 이러한 프로그래밍 언어에서는 캐리지 리턴(carriage return)이 구문들을 분리하는 역할을 한다.  
그러나 C++에서는 세미콜론이 구문의 끝을 표시한다. 이것은 C++에서 캐리지 리턴을 빈칸이나 탭과 같은 방식으로 자유롭게 사용할 수 있다는 것을 의미한다. 즉, C++에서는 캐리지 리턴을 사용할 수 있는 곳에 빈칸을 대신 사용할 수 있다는 뜻이다. 다시 말해서 이것은 하나의 구문을 여럴 행에 펼쳐 놓을 수도 있고, 여러 개의 구문을 한 행에 늘어 놓을 수도 있다는 것을 의미한다.  
따라서 myfirst.cpp 프로그램을 다음과 같은 모양으로 작성하는 것이 가능하다.
```
#include <iostream>        
int 
main
(){               
    using 
    namespace 
    std;   cout << "Welcome C++"; cout << endl;          
    cout << "My first C++"
     << endl; return 0;              
}                          
```  
여기서 주의해야 할 점은 이름과 같은 요소의 중간에 빈칸이나 탭, 캐리지 리턴을 넣을 수 없다는 것이다.

* ## 토큰과 화이트 스페이스
한 행의 코드에서 더 이상 분리할 수 없는 기본 요소를 토큰(token)이라 한다. 일반적으로 하나의 토큰은 빈칸, 탭, 캐리지 리턴에 의하여 다음 토큰과 분리된다. 빈칸, 탭, 캐리지 리턴을 집합적으로 화이트 스페이스(white space)라고 부른다. 괄호나 콤마와 같은 일부 단일 분자들은 화이트스페이스로 분리하지 않아도 되는 토큰이다.다음의 예는 화이트스페이스를 언제 사용할 수 있고, 언제 생략할 수 있는지 보여준다.
```
return0;            // 틀리다, return 0; 이어야 한다.
return(0);          // 맞다, 화이트스페이스가 생략되었다
return (0);         // 맞다, 화이트스페이스가 사용되었다
intmain();          // 틀리다, 화이트스페이스가 생략되었다
int main ();        // 맞다, ()안에 화이트스페이스가 생략되었다
int main ( );       //맞다, ( )안에 화이트스페이스가 사용되었다
```  

* ## C++ 소스 코드 스타일
C++ 프로그램은 매우 자유로운 스타일로 작성할 수 있다. 그러나 명쾌하고 정형화된 스타일로 프로그램을 작성하면 이해하기가 쉽다. 유요하기는 하지만 모양이 보기 흉한 프로그램은 무슨 내용인지 파악하기가 어렵다. 대부분의 C++ 프로그래머들은 Listing 2.1과 같은 스타일을 사용한다. 이 스타일은 다음과 같은 규칙을 따른다.
* 한 행에 하나의 구문을 사용한다.
* 함수를 여닫는 중괄호 {}에 각각 한 행을 할애한다.
* 함수 안에 들어갈 구문들은 중괄호에서 약간 오른쪽으로 들어간 위치에서 시작한다.
* 함수 이름과 괄호 사이에는 어떠한 화이트스페이스도 넣지 않는다.  

앞의 세 가지 규칙은 이해하기 쉽게 만들기 위한 것이고, 마지막 규칙은 루프와 같이 괄호를 사용하는 구성 요소와 함구를 구별하기 위한 것이다.